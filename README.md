# Мобильное приложение анализа состояния деревьев и зелёных насаждений

## 1. Назначение и область применения

Мобильное приложение `plants-recognition-app` предназначено для:

- загрузки фотографий деревьев и других зелёных насаждений с мобильного устройства (галерея или камера);
- передачи изображений на серверную модель компьютерного зрения;
- получения отчёта о состоянии растений (выделение объектов, дефектов, интегральные показатели состояния);
- визуализации результатов анализа (оверлей на изображении, сводные показатели, таблицы);
- локального хранения и последующего просмотра отчётов на устройстве.

Область применения:

- инвентаризация зелёных насаждений;
- контроль состояния деревьев в городской среде;
- поддержка принятия решений по уходу и обрезке;
- учебные и демонстрационные задачи по анализу изображений.

Приложение реализовано как кроссплатформенный клиент на базе Expo / React Native и ориентировано на Android и iOS.

## 2. Общая характеристика решения

Приложение представляет собой мобильный клиент, который:

1. Позволяет пользователю выбрать один или несколько снимков деревьев:
   - из галереи («Фото»);
   - через камеру («Камера»).

2. Отправляет каждое изображение на сервер по HTTP (формат `multipart/form-data`, поле `file`).

3. Получает от сервера структурированный ответ, содержащий:
   - идентификатор запроса (`request_id`);
   - параметры изображения;
   - набор выделенных объектов (растений) и их дефектов;
   - ссылку на оверлей-изображение с разметкой;
   - сводную таблицу по объектам.

4. Сохраняет:
   - «рабочее» изображение (оверлей или исходный снимок) в файловой системе устройства;
   - полный JSON-отчёт в локальное хранилище;
   - метаданные отчёта (дата, путь к файлу, полезная нагрузка) в `AsyncStorage`.

5. Предоставляет три основные вкладки:
   - **«Анализ»** – выбор изображений, запуск анализа, отображение статуса обработки;
   - **«Отчёты»** – список сохранённых отчётов;
   - **«Инфо»** – краткая инструкция по работе с приложением.

## 3. Технологический стек

Основные технологии и библиотеки:

- **Платформа**: Expo, React Native, TypeScript.
- **Навигация**: `expo-router` c таб-навигацией.
- **UI-компоненты**:
  - собственные компоненты (`GlassContainer`, `MainBackground`, `Button` и др.);
  - `@expo/vector-icons` (иконки).
- **Работа с изображениями**:
  - `react-native-image-crop-picker` (камера и галерея);
  - `expo-image` (отображение изображений).
- **Локальное хранение**:
  - `@react-native-async-storage/async-storage` (список отчётов);
  - `expo-file-system` (хранение файлов изображений и JSON-отчётов).
- **Инфраструктура**:
  - EAS (`eas.json`) для сборки установочных пакетов;
  - `expo-constants` для чтения настроек (`extra.API_BASE`).
- **Язык разработки**: TypeScript (конфигурация в `tsconfig.json`).

## 4. Структура проекта

Упрощённая структура директории проекта:

```text
.
├─ app/                       # Экранная логика и навигация (expo-router)
│  ├─ _layout.tsx             # Корневой layout
│  ├─ (tabs)/                 # Вкладки нижней навигации
│  │  ├─ _layout.tsx          # Layout таб-навигации («Анализ», «Отчеты», «Инфо»)
│  │  ├─ index.tsx            # Вкладка «Анализ»
│  │  ├─ reports.tsx          # Вкладка «Отчеты»
│  │  └─ about.tsx            # Вкладка «Инфо» (инструкция)
│  └─ reports/
│     └─ [id].tsx             # Экран детального отчёта по одному анализу
│
├─ components/                # Функциональные UI-компоненты
│  ├─ ImageProvider/          # Блок выбора фото/съёмки
│  ├─ LoadedContainer/        # Список выбранных изображений и управление очередью
│  ├─ loadingBlock/           # Индикация обработки
│  ├─ ReportsContainer/       # Контейнер списка отчётов
│  ├─ ReportPreview/          # Карточка отчёта в списке
│  ├─ PlantCard/              # Карточка одного растения в детальном отчёте
│  └─ toggleBar/              # Переключатель «Фото / Камера»
│
├─ ui/                        # Базовые стилевые компоненты
│  ├─ MainBackground/         # Общий фон
│  ├─ GlassContainer/         # Стеклянные карточки (glassmorphism)
│  ├─ Button/                 # Кнопка
│  ├─ BlurScreen/, BlurLayer/ # Эффекты размытия
│  └─ прочие вспомогательные элементы
│
├─ lib/
│  ├─ model/
│  │  └─ process.ts           # Основная логика вызова API и формирования отчёта
│  ├─ storage/
│  │  └─ reports.ts           # Локальное хранение отчётов (AsyncStorage + файловая система)
│  ├─ defectLabels.ts         # Словарь названий дефектов
│  └─ dev/
│     └─ createReport.ts      # Вспомогательный генератор тестового отчёта (для отладки)
│
├─ types/
│  ├─ Report.ts               # Типы данных отчёта и ответа сервера
│  └─ PickedImage.ts          # Тип обёртки над объектом ImagePicker
│
├─ assets/                    # Изображения, иконки, шрифты
├─ app.json                   # Конфигурация Expo (в т.ч. extra.API_BASE)
├─ eas.json                   # Профили сборок EAS
├─ package.json               # Зависимости и скрипты npm
├─ tsconfig.json              # Конфигурация TypeScript
└─ README.md                  # (данный файл)
```

## 5. Логика работы приложения

### 5.1. Вкладка «Анализ» (`app/(tabs)/index.tsx`)

Основные функции:

1. **Выбор режима ввода** (компонент `ToggleBar`):
   - «Фото» – выбор одного или нескольких изображений из галереи;
   - «Камера» – съёмка нового фото через камеру.

2. **Выбор / съёмка изображений** (компонент `ImageProvider`):
   - при режиме «Фото» используется `ImagePicker.openPicker({ multiple: true })`;
   - при режиме «Камера» используется `ImagePicker.openCamera(...)`;
   - выбранные изображения добавляются в массив `images`;
   - счётчик `reportsCounter` фиксирует общее количество изображений и количество обработанных.

3. **Просмотр очереди изображений** (компонент `LoadedContainer`):
   - отображает список выбранных изображений с превью;
   - позволяет очистить очередь при необходимости.

4. **Запуск обработки**:
   - для каждого изображения вызывается функция `process(image)` из `lib/model/process.ts`;
   - после успешной обработки всех изображений очередь очищается, а отчёты становятся доступны на вкладке «Отчеты».

5. **Индикация состояния**:
   - компонент `LoadingBlock` показывает прогресс обработки и текущий статус;
   - состояние кнопок и подсказок динамически зависит от наличия выбранных изображений и флага отправки.

### 5.2. Вкладка «Отчеты» (`app/(tabs)/reports.tsx`)

Функции:

- загрузка списка всех сохранённых отчётов через `getAllReports()` (`lib/storage/reports.ts`);
- подписка на событие `REPORTS_UPDATED_EVENT` через `DeviceEventEmitter` для автоматического обновления списка;
- отображение списка отчётов через `ReportsContainer` и компонент `ReportPreview` для каждого отчёта;
- при отсутствии отчётов выводится текст «Отчётов пока нет».

### 5.3. Вкладка «Инфо» (`app/(tabs)/about.tsx`)

Содержит краткую текстовую инструкцию по работе с приложением в виде нескольких пунктов:

1. Перейти во вкладку «Анализ».
2. Выбрать изображение из галереи или сделать снимок камерой.
3. Запустить анализ.
4. Перейти во вкладку «Отчёты» и открыть сформированный отчёт.

Текст оформлен в виде карточек (`GlassContainer`) и не содержит логики, влияющей на работу приложения.

### 5.4. Экран детального отчёта (`app/reports/[id].tsx`)

При открытии отчёта:

1. По идентификатору `id` загружается соответствующий `Report` функцией `getReport(id)`.

2. На основании `report.payload` формируется массив `instances: Instance[]`:
   - если `payload.instances` присутствует, используется он;
   - иначе выполняется адаптация «старого» формата с полями `plants` и `defects` (функция `normalizeInstances`):
     - растения и их дефекты объединяются по `plant_id` / `id`;
     - вычисляются поля:
       - `dry_branches_pct` (процент сухих ветвей, округлённый до целых);
       - `severity_score` (числовой показатель от 0 до 1, при необходимости рассчитывается на основе `health_score`).

3. По массиву `instances` вычисляются агрегированные показатели:
   - общее количество растений;
   - общее количество дефектов;
   - количество растений в категориях состояния:
     - `ok` – низкая степень поражения;
     - `med` – средняя;
     - `bad` – высокая.

4. На экране отображается:
   - изображение (оверлей или исходное фото);
   - идентификатор отчёта (`request_id`);
   - дата формирования отчёта;
   - сведения по исходному изображению (ширина и высота);
   - агрегированные счётчики;
   - список карточек растений (`PlantCard`);
   - при наличии `payload.table` – табличное представление по каждому объекту (идентификатор, тип, вид, дефекты, процент сухих ветвей, комментарии).

## 6. Взаимодействие с сервером

### 6.1. Конфигурация адреса API

Базовый URL API задаётся в `app.json`:

```json
{
  "expo": {
    "...": "...",
    "extra": {
      "API_BASE": "https://labs.timacad.ru"
    }
  }
}
```

В коде используется функция:

```ts
function getApiBase(): string {
  const extra = (Constants as any)?.expoConfig?.extra || (Constants as any)?.manifest?.extra || {};
  return extra.API_BASE || 'https://labs.timacad.ru';
}
```

Для смены сервера достаточно изменить значение `extra.API_BASE` и пересобрать приложение.

### 6.2. Точка загрузки изображений

Основная точка входа в серверное API:

```text
POST {API_BASE}/treehealth
Content-Type: multipart/form-data
Поле: file (изображение)
```

Фрагмент кода:

```ts
const API_BASE = getApiBase();
const UPLOAD_URL = `${API_BASE}/treehealth`;

const fd = new FormData();
fd.append('file', { uri: fileUri, name, type } as any);

const resp = await fetch(UPLOAD_URL, { method: 'POST', body: fd as any });
```

При неуспешном ответе (`!resp.ok`) формируется ошибка с кодом и текстом ответа сервера.

### 6.3. Формат ответа сервера

Тип ответа определён в `types/Report.ts`:

```ts
export type ImageMeta = { width: number; height: number };

export type DefectItem = {
  label: string;
  score: number;
  bbox?: [number, number, number, number];
};

export type Instance = {
  id: number;
  type: string; // 'tree' | 'shrub' | ...
  bbox: [number, number, number, number];
  mask_rle?: string | null;
  species?: { label: string; score: number } | null;
  defects: DefectItem[];
  dry_branches_pct?: number;    // 0..100
  severity_score?: number;      // 0..1
};

export type OverlayRef =
    | { mode: 'url'; value: string }
    | { mode: 'path'; value: string }
    | { mode: 'none'; value: '' }
    | { mode: string; value: string };

export type TableRow = {
  id: number;
  kind: string;
  species: string;
  defects: string;
  dry_branches_pct: number;
  notes?: string;
};

export type ServerResponse = {
  request_id: string;
  time_ms: number;
  image: ImageMeta;
  instances: Instance[];
  overlay: OverlayRef;
  table?: TableRow[];
};
```

Приложение также поддерживает «старый» формат, в котором вместо `instances` используются поля `plants` и `defects`. В этом случае выполняется преобразование в единый формат `Instance[]` (см. `normalizeInstances` в `app/reports/[id].tsx`).

### 6.4. Получение артефактов

На основании ответа сервера формируются ссылки на артефакты:

```ts
function pickOverlayUrl(base: string, payload: ServerResponse): string | null {
  const any: any = payload as any;
  const id = any?.request_id;
  if (!id) return null;

  if (any?.overlay?.mode === 'url' && typeof any.overlay?.value === 'string') {
    return any.overlay.value;
  }

  const srcPath =
      (any?.overlay?.value as string | undefined) ||
      (any?.extras?.overlay_url as string | undefined) ||
      (any?.overlay_path as string | undefined);

  const ext = extFromPath(srcPath); // jpg/jpeg/png (по умолчанию jpg)
  return `${base}/artifacts/${id}/overlay.${ext}`;
}

function pickReportUrl(base: string, payload: ServerResponse): string | null {
  const any: any = payload as any;
  const id = any?.request_id;
  if (!id) return null;
  return `${base}/artifacts/${id}/report.json`;
}
```

Полученный оверлей скачивается в директорию отчёта. При недоступности оверлея приложение копирует исходное изображение в директорию отчёта и использует его.

## 7. Локальное хранение отчётов

Логика хранения реализована в `lib/storage/reports.ts`.

### 7.1. Структура объекта `Report`

```ts
export type Report = {
  id: string;
  date: string;
  imageFile: string; // путь вида file://
  payload: ServerResponse;
};
```

### 7.2. Хранилище

- **Ключ в AsyncStorage**: `reports_v2`.
- **Структура в файловой системе**:  
  `FileSystem.documentDirectory + 'reports/{id}/'`, где:
  - `overlay.png` или `source.<ext>` – рабочее изображение;
  - `report.json` – полный JSON-ответ сервера.

Поддерживаются операции:

- `getAllReports()` – получить список всех отчётов;
- `getReport(id)` – получить отчёт по идентификатору;
- `saveReport(report)` – сохранить/обновить отчёт и отправить событие `REPORTS_UPDATED_EVENT`;
- `deleteReport(id)` – удалить выбранный отчёт и его директорию;
- `clearReports()` – очистить все отчёты и удалить директорию `reports`.

## 8. Требования к окружению

Минимальные требования для разработки:

- Node.js: актуальный LTS (рекомендуется ≥ 18.x).
- npm (предпочтительно использовать `npm`, так как присутствует `package-lock.json`).
- Установленный Expo CLI (доступен через `npx expo`).
- Android Studio / эмулятор Android (для сборок и отладки на эмуляторе под Android).
- Xcode (для сборок и эмуляции iOS; только на macOS).
- Устройство с установленным приложением Expo Go (при запуске через QR-код).

## 9. Установка и запуск в режиме разработки

### 9.1. Получение исходного кода

Варианты:

1. Клонирование репозитория (если проект хранится в системе контроля версий):

```bash
git clone <адрес-репозитория>
cd <директория-проекта>
```

2. Распаковка архива с исходным кодом и переход в корневую директорию проекта.

### 9.2. Установка зависимостей

```bash
npm install
```

### 9.3. Запуск дев-сервера Expo

```bash
npm run start
# или
npx expo start
```

После запуска:

- в терминале/браузере будет доступен DevTools;
- можно отсканировать QR-код приложением Expo Go на устройстве;
- либо запустить приложение на эмуляторе Android/iOS через меню DevTools.

## 10. Сборка установочных пакетов (EAS)

В файле `eas.json` заданы профили сборки:

- `development` – внутренние сборки с Development Client;
- `preview` – предварительные сборки (для Android задан тип `apk`);
- `production` – продуктивные сборки с автоинкрементом версий.

Примеры команд (требуют настроенного EAS и авторизации):

```bash
# Сборка dev-версии
eas build --profile development --platform android

# Сборка preview-версии (apk)
eas build --profile preview --platform android

# Сборка production-версии
eas build --profile production --platform android
eas build --profile production --platform ios
```

## 11. Типичные сценарии использования

### 11.1. Анализ одного снимка из галереи

1. Запустить приложение.
2. Перейти во вкладку «Анализ».
3. Убедиться, что выбран режим «Фото».
4. Нажать кнопку выбора изображения.
5. Выбрать одно изображение из галереи.
6. Запустить анализ.
7. После завершения обработки перейти во вкладку «Отчеты» и открыть созданный отчёт.
8. При необходимости просмотреть детальный отчёт: оверлей-разметку, список растений, дефекты, сводную таблицу.

### 11.2. Анализ серии снимков

1. Перейти во вкладку «Анализ».
2. В режиме «Фото» выбрать несколько изображений подряд.
3. Убедиться, что очередь изображений заполнена.
4. Запустить анализ – приложение последовательно отправит каждое изображение на сервер.
5. Следить за прогрессом.
6. После завершения обработки всех снимков перейти во вкладку «Отчеты» и просмотреть сформированные отчёты.

### 11.3. Анализ через камеру

1. Перейти во вкладку «Анализ».
2. Переключиться на режим «Камера».
3. Нажать кнопку «Сделать фото».
4. Сделать снимок растения.
5. Подтвердить использование снимка и запустить анализ.
6. После завершения обработки открыть отчёт на вкладке «Отчеты».

## 12. Логирование и обработка ошибок

В проекте используется консольное логирование:

- при отправке запроса и получении ответа;
- при ошибках запросов (`upload failed: ...`);
- при ошибках работы с файловой системой (`safeMkdir failed`, `overlay download failed`, `copy source failed`, `write report.json failed`);
- при нештатных ситуациях при обработке (`[process] FAILED`).

Базовая стратегия обработки ошибок:

- при неуспешном HTTP-ответе генерируется исключение с кодом и текстом ответа;
- при любом исключении во время обработки изображений возвращается результат вида `{ ok: false, error: string }`;
- на уровне UI возможна доработка для отображения пользователю понятных уведомлений на основе этих сообщений.

## 13. Известные ограничения и направления развития

1. **Зависимость от серверного API**  
   Клиент предполагает наличие работающего сервера с REST-интерфейсом, реализующего эндпоинт `POST /treehealth` и выдачу артефактов в формате, описанном в разделе 6.

2. **Отсутствие офлайн-анализа**  
   Вся аналитика выполняется на сервере; при отсутствии сети приложение может только отображать ранее сохранённые отчёты.

3. **Ограничения по размеру и количеству изображений**  
   Предельные размеры и количество отправляемых изображений зависят от настроек сервера и мобильной сети.

4. **Управление памятью и хранением**  
   При большом числе отчётов размер локального хранилища может значительно вырасти.

5. **Дальнейшее развитие интерфейса**  
   Возможны:
   - расширение визуализации (фильтры по состоянию, сортировки, дополнительные графики);
   - более развитый экран «Инфо»;
   - экспорт отчётов в PDF / Excel / CSV при необходимости.

## 14. Назначение документа

Данный README объединяет в себе:

- описание назначения и архитектуры мобильного приложения;
- технические детали взаимодействия с сервером;
- структуру данных и форматы ответов;
- инструкцию по сборке, запуску и использованию.

Документ может использоваться как отчёт о реализации клиентской части системы анализа состояния зелёных насаждений, а также как эксплуатационная инструкция для разработчиков и сопровождающих приложение.
